#!/bin/bash
#
# Claude Code Sandbox Container Wrapper Script
# ======================================
# This script runs Claude Code inside a Docker container with proper isolation
# while maintaining access to your workspace and git config.
#
# Usage: ./claude [args...]
#   ./claude                              # Start interactive session
#   ./claude --debug                      # Debug mode
#   ./claude -p /workspace                # Specify workspace path
#   ./claude --ssh-key id_ed25519         # Use specific SSH key
#   ./claude --ssh-key ~/.ssh/custom_key  # Use custom key path
#   ./claude --cpus 4                     # Allocate 4 CPUs
#   ./claude --memory 4g                  # Set memory limit to 4GB
#   ./claude "fix the bug"                # Execute prompt (auto-converted to -p)
#   ./claude --debug "analyze logs"       # Combine flags and prompts
#
# Environment Variables:
#   CLAUDE_SSH_KEY    # Default SSH key to use (e.g., "id_ed25519")
#
# The container automatically:
#   - Mounts your current directory as the workspace
#   - Syncs your git configuration and forwards SSH keys
#   - Generates unique container names for multiple instances
#   - Cleans up when the session ends (--rm flag)

set -e  # Exit on any error

# ============================================================================
# Configuration
# ============================================================================

CLAUDE_DIR="${HOME}/.claude-sandbox"        # Persistent config directory
IMAGE="claude-code-sandbox:latest"          # Docker image name
NAME_PREFIX="claude-sandbox-"               # Container name prefix
SSH_KEY="${CLAUDE_SSH_KEY:-id_ed25519}"     # SSH key to load (from env or flag)
CPUS="8"                                    # Default CPU allocation
MEMORY="8g"                                 # Default memory limit

# ============================================================================
# Argument Parsing
# ============================================================================
# Parse arguments to extract --ssh-key flag and detect prompts.
# Positional arguments (non-flags) are treated as prompts and automatically
# prefixed with -p for the Claude CLI.

CLAUDE_ARGS=()
PROMPT_ARG=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        --ssh-key)
            SSH_KEY="$2"
            shift 2
            ;;
        --ssh-key=*)
            SSH_KEY="${1#*=}"
            shift
            ;;
        --cpus)
            CPUS="$2"
            shift 2
            ;;
        --cpus=*)
            CPUS="${1#*=}"
            shift
            ;;
        --memory)
            MEMORY="$2"
            shift 2
            ;;
        --memory=*)
            MEMORY="${1#*=}"
            shift
            ;;
        -p|--print)
            # User explicitly passed -p, use next arg as prompt
            CLAUDE_ARGS+=("$1")
            shift
            ;;
        -*)
            # Other flags, pass through
            CLAUDE_ARGS+=("$1")
            shift
            ;;
        *)
            # Positional argument - treat as prompt if no flag prefix
            # Store it to add with -p later
            if [[ -z "$PROMPT_ARG" ]]; then
                PROMPT_ARG="$1"
            else
                # Multiple positional args - just pass through
                CLAUDE_ARGS+=("$1")
            fi
            shift
            ;;
    esac
done

# If we have a prompt argument without -p flag, add it properly
if [[ -n "$PROMPT_ARG" ]]; then
    CLAUDE_ARGS+=("-p" "$PROMPT_ARG")
fi

echo "ðŸš€ Claude Code Sandbox Container Launcher"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

mkdir -p "$CLAUDE_DIR"

# ============================================================================
# Docker Check
# ============================================================================
# Ensure Docker is running before attempting to launch containers

echo "ðŸ”§ Checking Docker..."

if ! docker info >/dev/null 2>&1; then
    echo "   âš  Docker not running, starting..."

    # Platform-specific startup
    case "$(uname -s)" in
        Darwin)
            if command -v orbctl &>/dev/null; then
                orbctl start 2>/dev/null || true
            elif [ -d "/Applications/Docker.app" ]; then
                open -a Docker
            fi
            ;;
        Linux)
            if command -v systemctl &>/dev/null; then
                sudo systemctl start docker 2>/dev/null || true
            fi
            ;;
    esac

    # Wait for Docker to be ready (up to 30 seconds)
    attempts=0
    while ! docker info >/dev/null 2>&1 && [ $attempts -lt 30 ]; do
        sleep 1
        ((attempts++))
    done

    if docker info >/dev/null 2>&1; then
        echo "   âœ“ Docker started successfully"
    else
        echo "   âœ— Failed to start Docker"
        exit 1
    fi
else
    echo "   âœ“ Docker is running"
fi

# ============================================================================
# Container Launch
# ============================================================================
# Generate a unique container name and launch with all necessary mounts

# Find the next available number for the container name
# by checking existing containers with the same prefix
NEXT_NUM=$(docker ps -a --format '{{.Names}}' 2>/dev/null | \
    grep -E "^${NAME_PREFIX}[0-9]+$" | \
    sed "s/^${NAME_PREFIX}//" | \
    sort -n | tail -1 | \
    awk '{print $1 + 1}')
NEXT_NUM=${NEXT_NUM:-0}

# Generate unique container name with incremental number
NAME="${NAME_PREFIX}${NEXT_NUM}"

echo "ðŸ³ Launching container: $NAME"
echo "ðŸ“ Workspace: $(pwd)"

# ============================================================================
# Setup: Git Configuration
# ============================================================================

echo "ðŸ“ Syncing git configuration..."

if [ -f "$HOME/.gitconfig" ]; then
    # Copy gitconfig to sandbox directory if it doesn't exist or is outdated
    if [ ! -f "$CLAUDE_DIR/.gitconfig" ] || [ "$HOME/.gitconfig" -nt "$CLAUDE_DIR/.gitconfig" ]; then
        cp -f "$HOME/.gitconfig" "$CLAUDE_DIR/.gitconfig"
        echo "   âœ“ Git config copied to sandbox"
    else
        echo "   â„¹ Git config already up to date"
    fi
else
    echo "   âš  No .gitconfig found in $HOME"
fi

# ============================================================================
# Setup: SSH Configuration
# ============================================================================

echo "ðŸ”‘ Loading SSH keys..."

# If SSH_KEY is specified, load only that key; otherwise load all keys
if [ -n "$SSH_KEY" ]; then
    # Resolve the SSH key path
    if [[ "$SSH_KEY" == /* ]] || [[ "$SSH_KEY" == ~* ]]; then
        # Absolute path or path with ~
        SSH_KEY_PATH="${SSH_KEY/#\~/$HOME}"
    else
        # Assume it's a key name in ~/.ssh/
        SSH_KEY_PATH="$HOME/.ssh/$SSH_KEY"
    fi

    # Verify the key exists
    if [ ! -f "$SSH_KEY_PATH" ]; then
        echo "   âœ— SSH key not found: $SSH_KEY_PATH"
        echo "   Available keys in ~/.ssh/:"
        ls -1 "$HOME/.ssh/" | grep -E '^(id_|.*\.pub$)' | grep -v '\.pub$' || echo "   (none found)"
        exit 1
    fi

    # Clear existing keys and add only the specified one
    ssh-add -D 2>/dev/null || true
    ssh-add "$SSH_KEY_PATH"
    echo "   âœ“ Loaded SSH key: $(basename "$SSH_KEY_PATH")"
else
    # Load all default keys
    ssh-add
    echo "   âœ“ Loaded all available SSH keys"
fi

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

# Build the docker run command with appropriate flags
# -it: Interactive terminal
# --rm: Remove container after exit
# -e SSH_AUTH_SOCK: Forward SSH agent (platform-specific socket path)
# -w: Set working directory
# -v: Volume mounts for config, workspace, and IDE settings

# Trap signals to ensure clean shutdown
cleanup() {
    echo ""
    echo "ðŸ›‘ Shutting down container..."
    docker stop "$NAME" 2>/dev/null || true
}
trap cleanup EXIT INT TERM

# Build SSH forwarding arguments based on platform
SSH_FORWARD_ARGS=()
case "$(uname -s)" in
    Darwin)
        # macOS: Use Docker Desktop/OrbStack magic socket
        SSH_FORWARD_ARGS=(
            -v "/run/host-services/ssh-auth.sock:/run/host-services/ssh-auth.sock"
            -e "SSH_AUTH_SOCK=/run/host-services/ssh-auth.sock"
        )
        ;;
    Linux)
        # Linux: Forward the actual SSH_AUTH_SOCK
        if [ -n "$SSH_AUTH_SOCK" ]; then
            SSH_FORWARD_ARGS=(
                -v "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK"
                -e "SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
            )
        fi
        ;;
esac

docker run -it --rm \
    -w "$(pwd)" \
    --name "$NAME" \
    --cpus "$CPUS" --memory "$MEMORY" \
    "${SSH_FORWARD_ARGS[@]}" \
    -v "$CLAUDE_DIR:/home/claude" \
    -v "$HOME/.claude/ide:/home/claude/.claude/ide:ro" \
    -v "$(pwd):$(pwd)" \
    "$IMAGE" "${CLAUDE_ARGS[@]}"

# Container exited, cleanup trap will handle the rest
